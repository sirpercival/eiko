import random, jsonimport shelve, osfrom difflib import SequenceMatcherfrom itertools import izipwith open(os.path.expanduser('~/eiko/usrmod/mrwelch.json')) as f:   foo = json.load(f)def welch(phenny, input):   try:      ind = int(input.group(2))   except:      ind = 1   if ind > 3:      ind = 3   out = random.sample(foo,ind)   for o in out:   	  phenny.say(o)welch.commands = ['welch','noes']welch.priority = 'low'def getpoll():    vote_db = shelve.open(os.path.expanduser('~/.phenny/polls'))    for p in vote_db:        thispoll = vote_db[p]        if thispoll['active']:            vote_db.close()            return thispoll    vote_db.close()    return Nonedef storepoll(poll):    vote_db = shelve.open(os.path.expanduser('~/.phenny/polls'))    vote_db[poll['index']] = poll    vote_db.close()def vote(phenny, input):    thispoll = getpoll()    if not thispoll:        phenny.say("Sorry, " + input.nick + ", there are no active polls " \            "at the moment. If you think this is a mistake, let sirp know.")        return    ratios = {}    for k in thispoll['voters']:        ratios[SequenceMatcher(None, k, input.nick).ratio()] = k    if ratios:        maxratio = max(ratios)        if maxratio > 0.7:            phenny.say("Hey! Hey, hey, hey! " + input.nick + ", you're being " \                "very naughty and trying to vote more than once.")            return    try:        votes = input.groups()[1]    except:        phenny.say("You, um, didn't give me a vote...")        return    try:        votes = [int(x) for x in votes.split()]    except:        phenny.say("You didn't vote by number! HOW DAREYOU (seriously, try again.)")        return    votes = set(votes)    if not thispoll['multivote'] and len(votes) > 1:        phenny.say("You can only vote for one option, so why don't you try that again.")        return    if len(votes) > len(thispoll['votes']):        phenny.say("You've voted for too many options. Try again, dude.")        return    for v in votes:        v -= 1        if v > len(thispoll['options']) - 1 or v < 0:            phenny.say("You've entered an invalid vote. PLEASE try again.")            return        thispoll['votes'][thispoll['options'][v]] += 1    thispoll['voters'].append(input.nick)    phenny.say("Thank you for voting, " + input.nick + "!")    storepoll(thispoll)vote.name = 'vote'vote.commands = ['vote']vote.priority = 'low'def poll(phenny, input):    thispoll = getpoll()    if not thispoll:        phenny.say("Sorry, " + input.nick + ", there are no active polls " \            "at the moment. If you think this is a mistake, let sirp know.")        return    j, votes = 0, []    results = []    for v in thispoll['options']:        j += 1        votes.append(thispoll['votes'][v])        results.append(str(j) + '. ' + v)    tot = sum(votes)    percents = [0 for x in votes] if not tot else \        [int(round(x * 100. / tot)) for x in votes]    print votes, tot, percents    out = [results[i] + ' ' + str(percents[i]) + '%' \        for i in range(len(results))]    phenny.say("Current poll question: " + thispoll['poll'])    phenny.say("Results: " + " ".join(out))    voters = "None!" if not thispoll['voters'] else \        ", ".join(sorted(thispoll['voters']))    phenny.say("Voted: " + voters)    msg = "To vote, use the .vote command, followed by the number(s) " \        "of your vote. You may only vote once."    if thispoll['multivote']:        msg += " However, you may vote for more than one option in this poll."    msg += " If you would like another option added to the poll, please " \        "contact sirp."    phenny.say(msg)poll.name = 'poll'poll.commands = ['poll']poll.priority = 'low'def newpoll(phenny, input):    if input.sender.startswith('#') or not input.admin:        return    text = input.groups()[1]    if not text:        return    text = text.split()    id = text[0].lower()    if id == 'list':        vote_db = shelve.open(os.path.expanduser('~/.phenny/polls'))        pollist = []        for p in vote_db:            if vote_db[p]['active']:                pollist.append(p + ' (active)')            else:                pollist.append(p)        phenny.say(', '.join(sorted(pollist)))        vote_db.close()        return    try:        opt = text[1].lower()    except:        phenny.say("What do you actually want to do?")        return    vote_db = shelve.open(os.path.expanduser('~/.phenny/polls'))    if opt == 'new':        try:            choice = text[2:]        except:            phenny.say("You need to include a poll question, bonehead.")            vote_db.close()            return        pollprompt = ' '.join(choice)        vote_db[id] = {'poll': pollprompt, 'votes': {}, 'voters': [], \            'multivote': False, 'active': False, 'index':id, 'options': []}    else:        if id not in vote_db:            phenny.say("This poll doesn't exist yet. Why don't you make it?")            vote_db.close()            return        if opt == 'activate':            for p in vote_db:                thispoll = vote_db[p]                thispoll['active'] = True if p == id else False                vote_db[p] = thispoll            vote_db.close()            phenny.say("Poll " + id + " active! All other polls disabled.")            return        if opt == 'delete':            del vote_db[id]            vote_db.close()            phenny.say("Poll " + id + " deleted!")            return        thispoll = vote_db[id]        if opt == 'add':            choice = text[2:]            thispoll['options'].append(' '.join(choice))            #thispoll['options'] = sorted(thispoll['options'])            thispoll['votes'][' '.join(choice)] = 0        elif opt == 'multi':            thispoll['multivote'] = True        elif opt == 'close':            thispoll['active'] = False        elif opt == 'reset':            for i in thispoll['votes']:                thispoll['votes'][i] = 0            thispoll['voters'] = []        vote_db[id] = thispoll    vote_db.close()newpoll.name = 'newpoll'newpoll.commands = ['newpoll']newpoll.priority = 'low'